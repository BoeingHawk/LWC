## **Topic 5: Modules & Imports (`import { xyz } from 'module'`)

### **1ï¸âƒ£ What Are Modules?**
Modules allow us to break JavaScript code into **separate files**, making it more organized and reusable. Using **ES6 Modules**, we can:
âœ… Export functions, objects, or variables from one file.
âœ… Import them into another file.

---

## **2ï¸âƒ£ Exporting & Importing in JavaScript**

### **A. Named Export & Import** (Used when exporting multiple items)
#### **Exporting (`math.js`)**

export const add = (a, b) => a + b;
export const multiply = (a, b) => a * b;

#### **Importing (`app.js`)**

import { add, multiply } from "./math.js";
console.log(add(2, 3)); // 5
console.log(multiply(2, 3)); // 6

âœ… **Use curly braces** `{}` while importing named exports.

---

### **B. Default Export & Import** (Used when exporting only one item)
#### **Exporting (`greet.js`)**

export default function greet(name) {
    return `Hello, ${name}!`;
}

#### **Importing (`app.js`)**

import greet from "./greet.js";
console.log(greet("Pulkit")); // Hello, Pulkit!

âœ… **No curly braces** needed for default imports.
âœ… **You can rename** the imported function.

---

### **C. Renaming Imports & Exports**
#### **Renaming Export (`math.js`)**

export { add as sum, multiply as product };

#### **Renaming Import (`app.js`)**

import { sum, product } from "./math.js";


âœ… Use **`as`** to rename exports or imports.

---

## **3ï¸âƒ£ Dynamic Imports (`import()`)**
If we donâ€™t want to load a module **until needed**, we use `import()` (also called **lazy loading**).

async function loadModule() {
    let { add } = await import("./math.js");
    console.log(add(4, 5)); // 9
}
loadModule();

âœ… Used in **code-splitting** to improve performance.

---

## **4ï¸âƒ£ Best Practices**
âœ”ï¸ Use **named exports** when exporting multiple things.
âœ”ï¸ Use **default export** when exporting only one thing.
âœ”ï¸ Use **dynamic imports** for large applications.
âœ”ï¸ Always specify **relative paths** (`./module.js`).

---

## âœ… **Your Task**
1. Create `math.js` with **two functions** (addition & subtraction).
2. Export them using **named exports**.
3. Import them into `app.js` and use them.

Once you complete this, weâ€™ll move to **Topic 6: Promises & Async/Await** ğŸš€

---

## **Topic 6: Promises & Async/Await**

JavaScript is **asynchronous**, meaning it can execute multiple tasks **without waiting** for one to finish before starting another. To handle asynchronous operations, we use **Promises** and **Async/Await**.

---

## **1ï¸âƒ£ What is a Promise?**  
A **Promise** is an object representing a task that will either **resolve** (success) or **reject** (failure) in the future.  

### **Promise States**
| State       | Meaning |
|------------|---------|
| **Pending**  | Initial state (not yet completed) |
| **Fulfilled** | Operation completed successfully |
| **Rejected**  | Operation failed |

### **2ï¸âƒ£ Creating a Promise**

const myPromise = new Promise((resolve, reject) => {
    let success = true;  // Try changing this to false

    setTimeout(() => {
        if (success) {
            resolve("âœ… Task completed!");
        } else {
            reject("âŒ Task failed!");
        }
    }, 2000);  // Simulating a 2-second delay
});


---

### **3ï¸âƒ£ Handling Promises with `.then()` and `.catch()`**

myPromise
    .then((result) => console.log(result))  // âœ… Success
    .catch((error) => console.log(error));  // âŒ Error


ğŸ’¡ **Best Practice:** Always handle `.catch()` to avoid uncaught errors.

---

## **4ï¸âƒ£ Async/Await: A Better Way to Handle Promises**  
Instead of `.then()` and `.catch()`, we use `async` and `await` to write **cleaner and readable** code.

### **Example: Converting a Promise to Async/Await**

async function fetchData() {
    try {
        let result = await myPromise;  // Waits until the Promise resolves
        console.log(result);
    } catch (error) {
        console.log(error);
    }
}

fetchData();


ğŸ’¡ **Key Points:**  
âœ… `await` pauses execution **until** the Promise resolves.  
âœ… `try/catch` handles errors more cleanly than `.catch()`.  

---

## **5ï¸âƒ£ Real-World Example: Fetching Data from an API**
### **Using `.then()`**

fetch("https://jsonplaceholder.typicode.com/posts/1")
    .then(response => response.json())  // Convert response to JSON
    .then(data => console.log(data))    // Log the data
    .catch(error => console.log(error));  // Handle errors


### **Using Async/Await**

async function getPost() {
    try {
        let response = await fetch("https://jsonplaceholder.typicode.com/posts/1");
        let data = await response.json();
        console.log(data);
    } catch (error) {
        console.log(error);
    }
}

getPost();

ğŸ’¡ **Which One to Use?**  
âœ… Use `.then()` when chaining multiple Promises.  
âœ… Use `async/await` for cleaner, **easier-to-read** code.  

---

## **6ï¸âƒ£ Promise.all() â€“ Running Multiple Promises in Parallel**
If you have multiple Promises that can run **at the same time**, use `Promise.all()`.


const promise1 = fetch("https://jsonplaceholder.typicode.com/posts/1").then(res => res.json());
const promise2 = fetch("https://jsonplaceholder.typicode.com/posts/2").then(res => res.json());

Promise.all([promise1, promise2])
    .then(results => console.log(results))
    .catch(error => console.log(error));

âœ… **Faster Execution** â€“ Runs both Promises at the same time.  
âœ… **Fails if Any Promise Fails** â€“ If **one** Promise rejects, the whole `Promise.all()` fails.

---

### âœ… **Your Task**
1ï¸âƒ£ Create a Promise that resolves after 3 seconds and logs `"Task Done!"`.  
2ï¸âƒ£ Convert it into an **async function** using `await`.  
3ï¸âƒ£ Fetch data from `https://jsonplaceholder.typicode.com/users/1` using **both `.then()` and `async/await`**.  

---


